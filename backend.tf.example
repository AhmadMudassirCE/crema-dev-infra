# Terraform Backend Configuration for Remote State Storage
#
# This file configures Terraform to store state remotely in AWS S3 with DynamoDB for state locking.
# Remote state is recommended for team environments and production deployments.
#
# SETUP INSTRUCTIONS:
# 1. Create an S3 bucket for state storage (see README.md for commands)
# 2. Create a DynamoDB table for state locking (see README.md for commands)
# 3. Copy this file: cp backend.tf.example backend.tf
# 4. Update the values below with your bucket and table names
# 5. Initialize Terraform: terraform init -migrate-state
#
# IMPORTANT: The S3 bucket and DynamoDB table must exist before running terraform init

terraform {
  backend "s3" {
    # S3 bucket name for storing Terraform state
    # Replace with your bucket name
    bucket = "my-terraform-state-bucket"
    
    # Path within the bucket where state will be stored
    # Use different keys for different environments (dev, staging, prod)
    key = "ecs-infrastructure/terraform.tfstate"
    
    # AWS region where the S3 bucket is located
    region = "us-east-1"
    
    # DynamoDB table name for state locking
    # Replace with your table name
    dynamodb_table = "terraform-state-lock"
    
    # Enable encryption at rest for state file
    encrypt = true
    
    # Optional: Use a specific AWS profile
    # profile = "terraform"
    
    # Optional: Use a specific IAM role for backend access
    # role_arn = "arn:aws:iam::123456789012:role/TerraformBackendRole"
  }
}

# BACKEND CONFIGURATION OPTIONS:
#
# 1. BASIC CONFIGURATION (shown above):
#    - S3 bucket for state storage
#    - DynamoDB table for state locking
#    - Encryption enabled
#
# 2. MULTI-ENVIRONMENT CONFIGURATION:
#    Use different state keys for different environments:
#    - Dev:     key = "ecs-infrastructure/dev/terraform.tfstate"
#    - Staging: key = "ecs-infrastructure/staging/terraform.tfstate"
#    - Prod:    key = "ecs-infrastructure/prod/terraform.tfstate"
#
# 3. WORKSPACE-BASED CONFIGURATION:
#    Use Terraform workspaces with a single backend:
#    key = "ecs-infrastructure/${terraform.workspace}/terraform.tfstate"
#
# 4. CROSS-ACCOUNT CONFIGURATION:
#    Use IAM role assumption for cross-account state access:
#    role_arn = "arn:aws:iam::ACCOUNT_ID:role/TerraformBackendRole"

# CREATING THE S3 BUCKET:
#
# aws s3api create-bucket \
#   --bucket my-terraform-state-bucket \
#   --region us-east-1
#
# # Enable versioning (recommended for state history)
# aws s3api put-bucket-versioning \
#   --bucket my-terraform-state-bucket \
#   --versioning-configuration Status=Enabled
#
# # Enable encryption (required for security)
# aws s3api put-bucket-encryption \
#   --bucket my-terraform-state-bucket \
#   --server-side-encryption-configuration '{
#     "Rules": [{
#       "ApplyServerSideEncryptionByDefault": {
#         "SSEAlgorithm": "AES256"
#       }
#     }]
#   }'
#
# # Enable bucket logging (optional, for audit trail)
# aws s3api put-bucket-logging \
#   --bucket my-terraform-state-bucket \
#   --bucket-logging-status '{
#     "LoggingEnabled": {
#       "TargetBucket": "my-logging-bucket",
#       "TargetPrefix": "terraform-state-logs/"
#     }
#   }'
#
# # Block public access (recommended for security)
# aws s3api put-public-access-block \
#   --bucket my-terraform-state-bucket \
#   --public-access-block-configuration \
#     BlockPublicAcls=true,\
#     IgnorePublicAcls=true,\
#     BlockPublicPolicy=true,\
#     RestrictPublicBuckets=true

# CREATING THE DYNAMODB TABLE:
#
# aws dynamodb create-table \
#   --table-name terraform-state-lock \
#   --attribute-definitions AttributeName=LockID,AttributeType=S \
#   --key-schema AttributeName=LockID,KeyType=HASH \
#   --billing-mode PAY_PER_REQUEST \
#   --region us-east-1
#
# # Enable point-in-time recovery (optional, for backup)
# aws dynamodb update-continuous-backups \
#   --table-name terraform-state-lock \
#   --point-in-time-recovery-specification PointInTimeRecoveryEnabled=true

# REQUIRED IAM PERMISSIONS FOR BACKEND:
#
# The AWS user or role running Terraform needs these permissions:
#
# S3 Permissions:
# - s3:ListBucket (on the bucket)
# - s3:GetObject (on the state file)
# - s3:PutObject (on the state file)
# - s3:DeleteObject (on the state file, for state cleanup)
#
# DynamoDB Permissions:
# - dynamodb:GetItem
# - dynamodb:PutItem
# - dynamodb:DeleteItem
#
# Example IAM Policy:
# {
#   "Version": "2012-10-17",
#   "Statement": [
#     {
#       "Effect": "Allow",
#       "Action": [
#         "s3:ListBucket"
#       ],
#       "Resource": "arn:aws:s3:::my-terraform-state-bucket"
#     },
#     {
#       "Effect": "Allow",
#       "Action": [
#         "s3:GetObject",
#         "s3:PutObject",
#         "s3:DeleteObject"
#       ],
#       "Resource": "arn:aws:s3:::my-terraform-state-bucket/*"
#     },
#     {
#       "Effect": "Allow",
#       "Action": [
#         "dynamodb:GetItem",
#         "dynamodb:PutItem",
#         "dynamodb:DeleteItem"
#       ],
#       "Resource": "arn:aws:dynamodb:us-east-1:*:table/terraform-state-lock"
#     }
#   ]
# }

# MIGRATING FROM LOCAL TO REMOTE STATE:
#
# 1. Ensure S3 bucket and DynamoDB table exist
# 2. Copy this file: cp backend.tf.example backend.tf
# 3. Update bucket and table names in backend.tf
# 4. Run: terraform init -migrate-state
# 5. Confirm the migration when prompted
# 6. Verify state was migrated: aws s3 ls s3://my-terraform-state-bucket/
# 7. Delete local state file: rm terraform.tfstate terraform.tfstate.backup

# MIGRATING FROM REMOTE TO LOCAL STATE:
#
# 1. Remove or rename backend.tf: mv backend.tf backend.tf.disabled
# 2. Run: terraform init -migrate-state
# 3. Confirm the migration when prompted
# 4. State will be downloaded to local terraform.tfstate file

# STATE LOCKING:
#
# DynamoDB provides state locking to prevent concurrent modifications:
# - When terraform apply runs, it acquires a lock in DynamoDB
# - Other terraform operations wait for the lock to be released
# - Lock is automatically released when operation completes
# - If terraform crashes, lock may need manual removal: terraform force-unlock <lock-id>

# BEST PRACTICES:
#
# 1. Use separate state files for different environments
#    - Different S3 keys: dev/terraform.tfstate, prod/terraform.tfstate
#    - Or different S3 buckets: dev-state-bucket, prod-state-bucket
#
# 2. Enable S3 versioning for state history and rollback capability
#
# 3. Enable S3 encryption for security (AES256 or KMS)
#
# 4. Use DynamoDB for state locking to prevent concurrent modifications
#
# 5. Restrict S3 bucket access with IAM policies and bucket policies
#
# 6. Enable S3 bucket logging for audit trail
#
# 7. Use separate AWS accounts for different environments
#
# 8. Regularly backup state files (S3 versioning provides this)
#
# 9. Never commit backend.tf with real credentials to version control
#
# 10. Use IAM roles instead of access keys when possible

# TROUBLESHOOTING:
#
# Error: "Error loading state: AccessDenied"
# - Check IAM permissions for S3 and DynamoDB
# - Verify bucket and table names are correct
# - Ensure bucket is in the correct region
#
# Error: "Error acquiring the state lock"
# - Another terraform process is running
# - Wait for it to complete or force unlock: terraform force-unlock <lock-id>
# - Check DynamoDB table for stuck locks
#
# Error: "NoSuchBucket: The specified bucket does not exist"
# - Create the S3 bucket before running terraform init
# - Verify bucket name is correct
# - Ensure bucket is in the correct region
#
# Error: "ResourceNotFoundException: Requested resource not found: Table: terraform-state-lock"
# - Create the DynamoDB table before running terraform init
# - Verify table name is correct
# - Ensure table is in the correct region

# COST CONSIDERATIONS:
#
# S3 Storage:
# - Standard storage: ~$0.023 per GB per month
# - State files are typically < 1 MB, so cost is minimal
#
# S3 Requests:
# - GET/PUT requests: ~$0.0004 per 1,000 requests
# - Terraform operations generate minimal requests
#
# DynamoDB:
# - Pay-per-request pricing: ~$1.25 per million write requests
# - State locking generates minimal requests
# - Typical cost: < $1 per month
#
# Total estimated cost: < $2 per month for typical usage

# SECURITY CONSIDERATIONS:
#
# 1. State files may contain sensitive data:
#    - Resource IDs and ARNs
#    - Configuration values
#    - Potentially secrets (avoid storing secrets in state)
#
# 2. Always enable S3 encryption
#
# 3. Restrict S3 bucket access:
#    - Use IAM policies
#    - Enable bucket policies
#    - Block public access
#
# 4. Enable S3 versioning for recovery
#
# 5. Enable CloudTrail for audit logging
#
# 6. Use separate state files for different environments
#
# 7. Never commit state files to version control
#
# 8. Regularly rotate AWS credentials
#
# 9. Use IAM roles with temporary credentials when possible
#
# 10. Monitor S3 access logs for unauthorized access
